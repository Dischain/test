Handling exceptions for multiple async requests with scalaz disjunction.

So here the sequence of operations I want to perform:

0. I need a several synchronouse functions which potentially may cause an exceptions (for example, perform IO).
1. And I need them to perform async so I wrap this functions in Future.
2. After all call them in parallel or synchronously (it's actually doesn't matter) with for-comprehension.
3. And construct some complex result from results of given functions.
4. But also I want to catch all erroneuse situations which might to occure.
5. Finally, return something like scala Either or scalaz disjunction \/ (which is more preferable for me)
in order the client code may to pattern match on it.

def asyncTask(p: Int): Future[(Throwable \/ Option[Int])] = Future {
  \/.fromTryCatch(Some(2 / p))
}

def complexRequest(p1: Int = 1, p2: Int = 0): Future[(Throwable \/ List[Option[Int]])] =
  for {
    r1 <- asyncTask(p1) // not throws, r1: Throwable \/ Option[Result] = \/-(Some(result))
    r2 <- asyncTask(p2) // throws, r1: Throwable \/ Option[Result] = -\/(Throwable)
  } yield List(r1, r2) sequenceU 

def someController(...) = {
  for { res <- complexRequest } yield res match {
    case -\/(err) = BadRequest
    case \/-(result) => result match {
      case Some(res: List) => Ok(SomeComplexResponseObject.apply(res).toJson)
      case None => NotFound
    }
  }
}
